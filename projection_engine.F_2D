      module projection_engine
c
      use parallelism
c

c  ...order of approximations
      integer :: ORDER
c  ...number of elements in one dimension
      integer :: SIZE

      contains

      subroutine initialize_parameters
      ORDER=1
      SIZE=2
      end subroutine initialize_parameters

      subroutine GaussRule(q,X,W)
c order of the function being interpolated
c X coordinates
c W weights
      implicit none
      integer(kind=4), intent(in)  :: q
      real   (kind=8), intent(out) :: X(0:q-1)
      real   (kind=8), intent(out) :: W(0:q-1)
      select case (q)
      case (1) ! p = 1
      X(0) = 0.0
      W(0) = 2.0
      case (2) ! p = 3
      X(0) = -0.5773502691896257645091487805019576 ! 1/sqrt(3)
      X(1) = -X(0)
      W(0) =  1.0
      W(1) =  W(0)
      case (3) ! p = 5
      X(0) = -0.7745966692414833770358530799564799 ! sqrt(3/5)
      X(1) =  0.0
      X(2) = -X(0)
      W(0) =  0.5555555555555555555555555555555556 ! 5/9
      W(1) =  0.8888888888888888888888888888888889 ! 8/9
      W(2) =  W(0)
      case (4) ! p = 7
      X(0) = -0.8611363115940525752239464888928094 ! sqrt((3+2*sqrt(6/5))/7)
      X(1) = -0.3399810435848562648026657591032448 ! sqrt((3-2*sqrt(6/5))/7)
      X(2) = -X(1)
      X(3) = -X(0)
      W(0) =  0.3478548451374538573730639492219994 ! (18-sqrt(30))/36
      W(1) =  0.6521451548625461426269360507780006 ! (18+sqrt(30))/36
      W(2) =  W(1)
      W(3) =  W(0)
      case (5) ! p = 9
      X(0) = -0.9061798459386639927976268782993929 ! 1/3*sqrt(5+2*sqrt(10/7))
      X(1) = -0.5384693101056830910363144207002086 ! 1/3*sqrt(5-2*sqrt(10/7))
      X(2) =  0.0
      X(3) = -X(1)
      X(4) = -X(0)
      W(0) =  0.2369268850561890875142640407199173 ! (322-13*sqrt(70))/900
      W(1) =  0.4786286704993664680412915148356382 ! (322+13*sqrt(70))/900
      W(2) =  0.5688888888888888888888888888888889 ! 128/225
      W(3) =  W(1)
      W(4) =  W(0)
      case (6)
      X(0) = -0.9324695142031520
      X(1) = -0.6612093864662645
      X(2) = -0.2386191860831969
      X(3) = -X(2)
      X(4) = -X(1)
      X(5) = -X(0)
      W(0) =  0.1713244923791703
      W(1) =  0.3607615730481386
      W(2) =  0.4679139345726911
      W(3) =  W(2)
      W(4) =  W(1)
      W(5) =  W(0)
      case (7)
      X(0) = -0.9491079123427585
      X(1) = -0.7415311855993944
      X(2) = -0.4058451513773972
      X(3) =  0.0
      X(4) = -X(2)
      X(5) = -X(1)
      X(6) = -X(0)
      W(0) =  0.1294849661688697
      W(1) =  0.2797053914892767
      W(2) =  0.3818300505051189
      W(3) =  0.4179591836734694
      W(4) =  W(2)
      W(5) =  W(1)
      W(6) =  W(0)
      case (8)
      X(0) = -0.9602898564975362
      X(1) = -0.7966664774136267
      X(2) = -0.5255324099163290
      X(3) = -0.1834346424956498
      X(4) = -X(3)
      X(5) = -X(2)
      X(6) = -X(1)
      X(7) = -X(0)
      W(0) =  0.1012285362903763
      W(1) =  0.2223810344533745
      W(2) =  0.3137066458778873
      W(3) =  0.3626837833783620
      W(4) =  W(3)
      W(5) =  W(2)
      W(6) =  W(1)
      W(7) =  W(0)
      case (9)
      X(0) = -0.9681602395076261
      X(1) = -0.8360311073266358
      X(2) = -0.6133714327005904
      X(3) = -0.3242534234038089
      X(4) =  0.0
      X(5) = -X(3)
      X(6) = -X(2)
      X(7) = -X(1)
      X(8) = -X(0)
      W(0) =  0.0812743883615744
      W(1) =  0.1806481606948574
      W(2) =  0.2606106964029354
      W(3) =  0.3123470770400029
      W(4) =  0.3302393550012598
      W(5) =  W(3)
      W(6) =  W(2)
      W(7) =  W(1)
      W(8) =  W(0)
      case (10)
      X(0) = -0.973906528517172
      X(1) = -0.865063366688985
      X(2) = -0.679409568299024
      X(3) = -0.433395394129247
      X(4) = -0.148874338981631
      X(5) = -X(4)
      X(6) = -X(3)
      X(7) = -X(2)
      X(8) = -X(1)
      X(9) = -X(0)
      W(0) =  0.066671344308688
      W(1) =  0.149451349150581
      W(2) =  0.219086362515982
      W(3) =  0.269266719309996
      W(4) =  0.295524224714753
      W(5) =  W(4)
      W(6) =  W(3)
      W(7) =  W(2)
      W(8) =  W(1)
      W(9) =  W(0)
      case default
      X = 0.0
      W = 0.0
      end select
      end subroutine GaussRule 
 
c p=polynomial order
c m=
c U= knot vector
c d=0
c q=p+1 (order for Gauss integration)
c r=number of elements
c O,J,W,X,N output
      subroutine BasisData(p,m,U,d,q,r,O,J,W,X,N)
      implicit none
      integer(kind=4), intent(in)  :: p, m
      real   (kind=8), intent(in)  :: U(0:m)
      integer(kind=4), intent(in)  :: d, q, r
      integer(kind=4), intent(out) :: O(r)
      real   (kind=8), intent(out) :: J(r)
      real   (kind=8), intent(out) :: W(q)
      real   (kind=8), intent(out) :: X(q,r)
      real   (kind=8), intent(out) :: N(0:d,0:p,q,r)  

      integer(kind=4) i, iq, ir
      real   (kind=8) uu, Xg(q)
      real   (kind=8) basis(0:p,0:d)

      ir = 1
      do i = p, m-p
         if (U(i) /= U(i+1)) then
            O(ir) = i - p
            ir = ir + 1
         end if
      end do
      call GaussRule(q,Xg,W)
      do ir = 1, r
         i = O(ir) + p
         J(ir) = (U(i+1)-U(i))/2.0
         X(:,ir) = (Xg + 1.0) * J(ir) + U(i)
         do iq = 1, q
            uu = X(iq,ir)
            call DersBasisFuns(i,uu,p,d,U,basis)
            N(:,:,iq,ir) = transpose(basis)
         end do
      end do
      end subroutine BasisData
 
      subroutine DersBasisFuns(i,uu,p,n,U,ders)
      implicit none
      integer(kind=4), intent(in) :: i, p, n
      real   (kind=8), intent(in) :: uu, U(0:i+p)
      real   (kind=8), intent(out):: ders(0:p,0:n)
      integer(kind=4) :: j, k, r, s1, s2, rk, pk, j1, j2
      real   (kind=8) :: saved, temp, d
      real   (kind=8) :: left(p), right(p)
      real   (kind=8) :: ndu(0:p,0:p), a(0:1,0:p)
      ndu(0,0) = 1.0
      do j = 1, p
         left(j)  = uu - U(i+1-j)
         right(j) = U(i+j) - uu
         saved = 0.0
         do r = 0, j-1
            ndu(j,r) = right(r+1) + left(j-r)
            temp = ndu(r,j-1) / ndu(j,r)
            ndu(r,j) = saved + right(r+1) * temp
            saved = left(j-r) * temp
         end do
         ndu(j,j) = saved
      end do
      ders(:,0) = ndu(:,p)
      do r = 0, p
         s1 = 0; s2 = 1;
         a(0,0) = 1.0
         do k = 1, n
            d = 0.0
            rk = r-k; pk = p-k;
            if (r >= k) then
               a(s2,0) = a(s1,0) / ndu(pk+1,rk)
               d =  a(s2,0) * ndu(rk,pk)
            end if
            if (rk > -1) then
               j1 = 1
            else
               j1 = -rk
            end if
            if (r-1 <= pk) then
               j2 = k-1
            else
               j2 = p-r
            end if
            do j = j1, j2
               a(s2,j) = (a(s1,j) - a(s1,j-1)) / ndu(pk+1,rk+j)
               d =  d + a(s2,j) * ndu(rk+j,pk)
            end do
            if (r <= pk) then
               a(s2,k) = - a(s1,k-1) / ndu(pk+1,r)
               d =  d + a(s2,k) * ndu(r,pk)
            end if
            ders(r,k) = d
            j = s1; s1 = s2; s2 = j;
         end do
      end do
      r = p
      do k = 1, n
         ders(:,k) = ders(:,k) * r
         r = r * (p-k)
      end do
      end subroutine DersBasisFuns  

      function FindSpan(n,p,uu,U) result (span)
      implicit none
      integer(kind=4), intent(in) :: n, p
      real   (kind=8), intent(in) :: uu, U(0:n+p+1)
      integer(kind=4)             :: span
      integer(kind=4) low, high
      if (uu >= U(n+1)) then
         span = n
         return
      end if
      if (uu <= U(p)) then
         span = p
         return
      end if
      low  = p
      high = n+1
      span = (low + high) / 2
      do while (uu < U(span) .or. uu >= U(span+1))
         if (uu < U(span)) then
            high = span
         else
            low  = span
         end if
         span = (low + high) / 2
      end do
      end function FindSpan
 
      function CountSpans(n,p,U) result (nelem)
      implicit none
      integer(kind=4), intent(in) :: n, p
      real   (kind=8), intent(in) :: U(0:n+p+1)
      integer(kind=4) :: i,nelem  
 
      nelem = 0
      i=p
      do while (i.le.n)
         do while ((i.le.n) .and. (U(i) == U(i+1)))
            i = i + 1
         end do
         nelem = nelem + 1
         i = i + 1
      end do
      end function CountSpans 
 
      subroutine Form1DMassMatrix(KL,KU,U,p,n,nelem,M)
      !!$ KL = number of subdiagonals, KU = number of superdiagonals
      !!$ d is dimension
      !!$ U is the knot vector
      !!$ p is the polynomial order
      !!$ n is the index of the last control point
      !!$ nelem you get from running CountSpans
      !!$ M is the dense matrix
      implicit none
      integer :: KL,KU
      integer(kind=4), intent(in) :: n, p, nelem
      real   (kind=8), intent(in) :: U(0:n+p+1)
c M is a band storage matrix A(n,n)->M(2*KL+KU+1,n)
      double precision, intent(out) :: M(0:(2*KL+KU),0:n)
c      double precision, intent(out) :: M(0:n,0:n)
      integer(kind=4) :: mm,ng,e,k,a,b
      integer(kind=4) :: O(nelem)
      real   (kind=8) :: J(nelem)
      real   (kind=8) :: W(p+1)
      real   (kind=8) :: X(p+1,nelem)
c      real   (kind=8) :: NN(0:d,0:p,p+1,nelem)
      real   (kind=8) :: NN(0:0,0:p,p+1,nelem)
      integer :: d
      integer :: nrepp !# elements per processor
      integer :: iprint
c
      iprint=0
c      if(MYRANK.eq.0)iprint=1
c
      mm  = n+p+1
      ng  = p+1
      d = 0
      call BasisData(p,mm,U,d,ng,nelem,O,J,W,X,NN) 
      M = 0.d0
c loop over elements
      do e = 1,nelem
c loop over Gauss points
         do k = 1,ng
c loop over shape functions over elements (p+1 functions)
           do a = 0,p
c loop over shape functions over elements (p+1 functions)
              do b = 0,p
c O(e) + a = first dof of element + 1st local shape function index
c O(e) + b = first dof of element + 2nd local shape function index
c NN(0,a,k,e) = value of shape function a at Gauss point k over element e
c NN(0,b,k,e) = value of shape function b at Gauss point k over element e
c W(k) weight for Gauss point k
c J(e) jacobian ? for element e

c M is a band storage matrix A(i,j)->M(KL+KU+1+i-j,j)
c                 write(*,*)'i,j',O(e)+a,O(e)+b,'->',
c     .             KL+KU+O(e)+a-(O(e)+b),O(e)+b
                 M(KL+KU+O(e)+a-(O(e)+b),O(e)+b) =
     .             M(KL+KU+O(e)+a-(O(e)+b),O(e)+b) +
     .               NN(0,a,k,e)*NN(0,b,k,e)*J(e)*W(k)
c                 M(O(e)+a,O(e)+b) =
c     .             M(O(e)+a,O(e)+b) + NN(0,a,k,e)*NN(0,b,k,e)*J(e)*W(k)
              end do
           end do
        end do
      end do

      end subroutine Form1DMassMatrix

c-> DEBUG
      subroutine Form1DMassMatrixFULL(U,p,n,nelem,M) 
      !!$ d is dimension
      !!$ U is the knot vector
      !!$ p is the polynomial order
      !!$ n is the index of the last control point
      !!$ nelem you get from running CountSpans
      !!$ M is the dense matrix
      implicit none
      integer(kind=4), intent(in) :: n, p, nelem
      real   (kind=8), intent(in) :: U(0:n+p+1)
      double precision, intent(out) :: M(0:n,0:n)
      integer(kind=4) :: mm,ng,e,k,a,b
      integer(kind=4) :: O(nelem)
      real   (kind=8) :: J(nelem)
      real   (kind=8) :: W(p+1)
      real   (kind=8) :: X(p+1,nelem)
c      real   (kind=8) :: NN(0:d,0:p,p+1,nelem)
      real   (kind=8) :: NN(0:0,0:p,p+1,nelem)
      integer :: d
c
      mm  = n+p+1
      ng  = p+1
      d = 0
      call BasisData(p,mm,U,d,ng,nelem,O,J,W,X,NN) 

      M = 0.d0
c loop over elements
      do e = 1,nelem
c loop over Gauss points
         do k = 1,ng
c loop over shape functions over elements (p+1 functions)
           do a = 0,p
c loop over shape functions over elements (p+1 functions)
              do b = 0,p
c O(e) + a = first dof of element + 1st local shape function index
c O(e) + b = first dof of element + 2nd local shape function index
c NN(0,a,k,e) = value of shape function a at Gauss point k over element e
c NN(0,b,k,e) = value of shape function b at Gauss point k over element e
c W(k) weight for Gauss point k
c J(e) jacobian ? for element e
                 M(O(e)+a,O(e)+b) = 
     .             M(O(e)+a,O(e)+b) + NN(0,a,k,e)*NN(0,b,k,e)*J(e)*W(k)
              end do
           end do
        end do
      end do

      end subroutine Form1DMassMatrixFULL
c<- DEBUG


c Ux,Uy,Uz - knots vectors
c px,py,py - orders
c nx,ny,nz - number of intervals (problems size is (nx+1)*(ny+1)*(nz+1)
c nelemx,nelemy,nelemz - number of elements
c F output rhs (multiple vectors)
      subroutine Form3DRHS
     .   (Ux,px,nx,nelemx,Uy,py,ny,nelemy,Uz,pz,nz,nelemz, 
     .    ibegy,iendy,nranky,nrpy,
     .    ibegz,iendz,nrankz,nrpz,F)
      implicit none
      integer(kind=4), intent(in) :: nx, px, nelemx
      integer(kind=4), intent(in) :: ny, py, nelemy
      integer(kind=4), intent(in) :: nz, pz, nelemz
      real   (kind=8), intent(in) :: Ux(0:nx+px+1)
      real   (kind=8), intent(in) :: Uy(0:ny+py+1)
      real   (kind=8), intent(in) :: Uz(0:nz+pz+1)
c MP start from a system fully generated for X direction
      double precision, intent(out) :: F(0:nx,
     .     0:(iendy-ibegy+1)*(iendz-ibegz+1)-1)
c      double precision, intent(out) :: F(0:(iendx-ibegx+1)-1,
c     .     0:(iendy-ibegy+1)*(iendz-ibegz+1)-1)
      integer(kind=4) :: mx,my,mz,ngx,ngy,ngz,ex,ey,ez
      integer(kind=4) :: kx,ky,kz,ax,ay,az,d
      integer(kind=4) :: Ox(nelemx),Oy(nelemy),Oz(nelemz)
      real   (kind=8) :: Jx(nelemx),Jy(nelemy),Jz(nelemz)
      real   (kind=8) :: Wx(px+1),Wy(py+1),Wz(pz+1)
      real   (kind=8) :: Xx(px+1,nelemx)
      real   (kind=8) :: Xy(py+1,nelemy)
      real   (kind=8) :: Xz(pz+1,nelemz)
      real   (kind=8) :: NNx(0:0,0:px,px+1,nelemx),
     .                   NNy(0:0,0:py,py+1,nelemy),
     .                   NNz(0:0,0:pz,pz+1,nelemz)
c      real   (kind=8) :: NNx(0:d,0:px,px+1,nelemx),
c     .                   NNy(0:d,0:py,py+1,nelemy),
c     .                   NNz(0:d,0:pz,pz+1,nelemz)
      real   (kind=8) :: J,W,value
      integer, intent(in) :: ibegy,ibegz
      integer, intent(in) :: iendy,iendz
      integer, intent(in) :: nranky,nrankz
      integer, intent(in) :: nrpy,nrpz
      integer :: nreppx,nreppy,nreppz !# elements per proc along x,y,z
      integer :: ind,ind1,ind23,ind23a,indx,indy,indz
      integer :: iprint

      iprint=0
c      if(MYRANK.eq.0)iprint=1

      d=0
      mx  = nx+px+1
      ngx = px+1
      my  = ny+py+1
      ngy = py+1
      mz  = nz+pz+1
      ngz = pz+1

      call BasisData(px,mx,Ux,0,ngx,nelemx,Ox,Jx,Wx,Xx,NNx)
      call BasisData(py,my,Uy,0,ngy,nelemy,Oy,Jy,Wy,Xy,NNy)
      call BasisData(pz,mz,Uz,0,ngz,nelemz,Oz,Jz,Wz,Xz,NNz)

c-> parallel number of elements per processors
      nreppy = nelemy/nrpy
      nreppz = nelemz/nrpz
      if(iprint.eq.1)then
        write(*,*)PRINTRANK,'ey:',max(nreppy*nranky-py+1,1),
     .         min(nelemy,nreppy*(nranky+1)+py)
        write(*,*)PRINTRANK,'ez:',max(nreppz*nrankz-pz+1,1),
     .         min(nelemz,nreppz*(nrankz+1)+pz)
        write(*,*)PRINTRANK,'ibegy,iendy',ibegy,iendy
        write(*,*)PRINTRANK,'ibegz,iendz',ibegz,iendz
      endif
c<- parallel
      F = 0.d0
c-> parallel
      do ex = 1,nelemx
c MP start from a system fully generated for X direction
c       do ex = max(nreppx*nrankx-px+1,1),
c     .         min(nelemx,nreppx*(nrankx+1)+px)
c         do ey = 1,nelemy
         do ey = max(nreppy*nranky-py+1,1),
     .           min(nelemy,nreppy*(nranky+1)+py)
c            do ez = 1,nelemz
            do ez = max(nreppz*nrankz-pz+1,1),
     .              min(nelemz,nreppz*(nrankz+1)+pz)
c<- parallel
               J = Jx(ex)*Jy(ey)*Jz(ez)
               do kx = 1,ngx
                  do ky = 1,ngy
                     do kz = 1,ngz
                        W = Wx(kx)*Wy(ky)*Wz(kz)
                        value = fvalue(Xx(kx,ex),Xy(ky,ey),Xz(kz,ez))
                        do ax = 0,px
                           do ay = 0,py
                              do az = 0,pz
                                 ind = (Ox(ex)+ax)+(Oy(ey)+ay)*(nx+1)+
     .                               (Oz(ez)+az)*(ny+1)*(nx+1)
                                 call global2local(ind,indx,indy,indz,
     .                              nx,ny,nz)
c MP start from a system fully generated for X direction
c                                 if(indx.lt.ibegx-1.or.
c     .                              indx.gt.iendx-1)cycle
                                 if(indy.lt.ibegy-1.or.
     .                              indy.gt.iendy-1)cycle
                                 if(indz.lt.ibegz-1.or.
     .                              indz.gt.iendz-1)cycle
c MP start from a system fully generated for X direction
                                 ind1 = indx
c                                 ind1 = indx-ibegx+1
                                 ind23 = (indy-ibegy+1)+
     .                             (indz-ibegz+1)*(iendy-ibegy+1)
                                 if(iprint.eq.1)then
                                   write(*,*)PRINTRANK,'ind->x,y,z',
     .                                ind,indx,indy,indz,'->',ind1,ind23
                                 endif
c MP start from a system fully generated for X direction
c                        if(ind1.lt.0.or.ind1.gt.(iendx-ibegx))cycle
                        if(ind23.lt.0.or.ind23.gt.
     .                     (iendy-ibegy+1)*(iendz-ibegz+1)-1)cycle
c<- parallel
                                 F(ind1,ind23) = F(ind1,ind23) + 
     .                               NNx(0,ax,kx,ex)*
     .                               NNy(0,ay,ky,ey)*
     .                               NNz(0,az,kz,ez)*J*W*value
                        if(iprint.eq.1)then
                           write(*,*)PRINTRANK,
     .                      'ind',ind,'->',ind1,ind23,
     .                      ex,ey,ez
                        endif
                              end  do
                           end do
                        end do

                     end do
                  end do
               end do         

            end do
         end do
      end do
  
      end subroutine Form3DRHS

c-> DEBUG
c Ux,Uy,Uz - knots vectors
c px,py,py - orders
c nx,ny,nz - number of intervals (problems size is (nx+1)*(ny+1)*(nz+1)
c nelemx,nelemy,nelemz - number of elements
c F output rhs (multiple vectors)
      subroutine Form3DRHSFULL
     .   (Ux,px,nx,nelemx,Uy,py,ny,nelemy,Uz,pz,nz,nelemz,F) 
      implicit none
      integer(kind=4), intent(in) :: nx, px, nelemx
      integer(kind=4), intent(in) :: ny, py, nelemy
      integer(kind=4), intent(in) :: nz, pz, nelemz
      real   (kind=8), intent(in) :: Ux(0:nx+px+1)
      real   (kind=8), intent(in) :: Uy(0:ny+py+1)
      real   (kind=8), intent(in) :: Uz(0:nz+pz+1)
      double precision, intent(out) :: F(0:(nx+1)*(ny+1)*(nz+1)-1)
      integer(kind=4) :: mx,my,mz,ngx,ngy,ngz,ex,ey,ez
      integer(kind=4) :: kx,ky,kz,ax,ay,az,d
      integer(kind=4) :: Ox(nelemx),Oy(nelemy),Oz(nelemz)
      real   (kind=8) :: Jx(nelemx),Jy(nelemy),Jz(nelemz)
      real   (kind=8) :: Wx(px+1),Wy(py+1),Wz(pz+1)
      real   (kind=8) :: Xx(px+1,nelemx)
      real   (kind=8) :: Xy(py+1,nelemy)
      real   (kind=8) :: Xz(pz+1,nelemz)
      real   (kind=8) :: NNx(0:0,0:px,px+1,nelemx),
     .                   NNy(0:0,0:py,py+1,nelemy),
     .                   NNz(0:0,0:pz,pz+1,nelemz)
c      real   (kind=8) :: NNx(0:d,0:px,px+1,nelemx),
c     .                   NNy(0:d,0:py,py+1,nelemy),
c     .                   NNz(0:d,0:pz,pz+1,nelemz)
      real   (kind=8) :: J,W,value
      integer :: ind
      d=0
      mx  = nx+px+1
      ngx = px+1
      my  = ny+py+1
      ngy = py+1
      mz  = nz+pz+1
      ngz = pz+1

      call BasisData(px,mx,Ux,0,ngx,nelemx,Ox,Jx,Wx,Xx,NNx)
      call BasisData(py,my,Uy,0,ngy,nelemy,Oy,Jy,Wy,Xy,NNy)
      call BasisData(pz,mz,Uz,0,ngz,nelemz,Oz,Jz,Wz,Xz,NNz)

      F = 0.d0
      do ex = 1,nelemx
         do ey = 1,nelemy
            do ez = 1,nelemz
               J = Jx(ex)*Jy(ey)*Jz(ez)
               do kx = 1,ngx
                  do ky = 1,ngy
                     do kz = 1,ngz
                        W = Wx(kx)*Wy(ky)*Wz(kz)
                        value = fvalue(Xx(kx,ex),Xy(ky,ey),Xz(kz,ez))
                        do ax = 0,px
                           do ay = 0,py
                              do az = 0,pz
                                 ind = (Oz(ez)+az)*(ny+1)*(nx+1)
                                 ind = ind + (Oy(ey)+ay)*(nx+1)
                                 ind = ind + (Ox(ex)+ax)
                         if(ind.gt.(nx+1)*(ny+1)*(nz+1))then
                           write(*,*)'Form3DRHSFULL:indexing problem'
                           stop
                         endif
                                 F(ind) = F(ind) + 
     .                               NNx(0,ax,kx,ex)*
     .                               NNy(0,ay,ky,ey)*
     .                               NNz(0,az,kz,ez)*J*W*value
                              end  do
                           end do
                        end do

                     end do
                  end do
               end do         

            end do
         end do
      end do
  
      end subroutine Form3DRHSFULL
c<- DEBUG

c Ux,Uy,Uz - knots vectors
c px,py,py - orders
c nx,ny,nz - number of intervals (problems size is (nx+1)*(ny+1)*(nz+1)
c nelemx,nelemy,nelemz - number of elements
c F input rhs (multiple vectors) 
c F2 output rhs
      subroutine ReorderRHSForY
     .   (Ux,px,nx,nelemx,Uy,py,ny,nelemy,Uz,pz,nz,nelemz, 
     .    ibegyYZ,iendyYZ,nrankyYZ,
     .    ibegzYZ,iendzYZ,nrankzYZ,
     .    ibegxXZ,iendxXZ,nrankxXZ,
     .    ibegzXZ,iendzXZ,nrankzXZ,
     .    nrpx,nrpy,nrpz,F,F2)
      implicit none
      integer(kind=4), intent(in) :: nx, px, nelemx
      integer(kind=4), intent(in) :: ny, py, nelemy
      integer(kind=4), intent(in) :: nz, pz, nelemz
      real   (kind=8), intent(in) :: Ux(0:nx+px+1)
      real   (kind=8), intent(in) :: Uy(0:ny+py+1)
      real   (kind=8), intent(in) :: Uz(0:nz+pz+1)
      double precision, intent(in) :: F(0:nx,
     .   0:(iendyYZ-ibegyYZ+1)*(iendzYZ-ibegzYZ+1)-1)
      double precision, intent(out) :: F2(0:ny,
     .   0:(iendxXZ-ibegxXZ+1)*(iendzXZ-ibegzXZ+1)-1)
      integer(kind=4) :: mx,my,mz,ngx,ngy,ngz,ex,ey,ez
      integer(kind=4) :: kx,ky,kz,ax,ay,az,d
      integer(kind=4) :: Ox(nelemx),Oy(nelemy),Oz(nelemz)
      real   (kind=8) :: Jx(nelemx),Jy(nelemy),Jz(nelemz)
      real   (kind=8) :: Wx(px+1),Wy(py+1),Wz(pz+1)
      real   (kind=8) :: Xx(px+1,nelemx)
      real   (kind=8) :: Xy(py+1,nelemy)
      real   (kind=8) :: Xz(pz+1,nelemz)
      real   (kind=8) :: NNx(0:0,0:px,px+1,nelemx),
     .                   NNy(0:0,0:py,py+1,nelemy),
     .                   NNz(0:0,0:pz,pz+1,nelemz)
      integer, intent(in) :: ibegyYZ,iendyYZ,ibegzYZ,iendzYZ
      integer, intent(in) :: ibegxXZ,iendxXZ,ibegzXZ,iendzXZ
      integer, intent(in) :: nrankyYZ,nrankzYZ,nrankxXZ,nrankzXZ
      integer, intent(in) :: nrpx,nrpy,nrpz
      integer :: nreppx,nreppy,nreppz !# elements per proc along x,y,z
      real   (kind=8) :: J,W,value
      integer :: ind,ind1,ind23,ind2,ind13,indx,indy,indz
      integer :: iprint
c
      iprint=0
c
      d=0
      mx  = nx+px+1
      ngx = px+1
      my  = ny+py+1
      ngy = py+1
      mz  = nz+pz+1
      ngz = pz+1

      call BasisData(px,mx,Ux,0,ngx,nelemx,Ox,Jx,Wx,Xx,NNx)
      call BasisData(py,my,Uy,0,ngy,nelemy,Oy,Jy,Wy,Xy,NNy)
      call BasisData(pz,mz,Uz,0,ngz,nelemz,Oz,Jz,Wz,Xz,NNz)

c-> parallel number of elements per processors
      nreppx = nelemx/nrpx
      nreppy = nelemy/nrpy
      nreppz = nelemz/nrpz
c<- parallel
      F2 = 0.d0
c-> parallel
c MP now we have full X for reading from F
c but only partial X for writing to F2
      do ex = 1,nelemx
c       do ex = max(nreppx*nrankx-px+1,1),
c     .         min(nelemx,nreppx*(nrankx+1)+px)
c MP now we have full Y for writing to F2
c but only partial Y for reading from F
         do ey = 1,nelemy
c         do ey = max(nreppy*nranky-py+1,1),
c     .           min(nelemy,nreppy*(nranky+1)+py)
c MP Z is partial as it was before
c            do ez = 1,nelemz
            do ez = max(nreppz*nrankzYZ-pz+1,1),
     .              min(nelemz,nreppz*(nrankzYZ+1)+pz)
c<- parallel
                do ax = 0,px
                   do ay = 0,py
                      do az = 0,pz
c  ......................prepare indices for XZ (for F2)
                         ind = (Oy(ey)+ay)+(Ox(ex)+ax)*(ny+1)+
     .                         (Oz(ez)+az)*(nx+1)*(ny+1)
                         call global2local(ind,indx,indy,indz,
     .                        nx,ny,nz)
                         if(indx.lt.ibegxXZ-1.or.
     .                      indx.gt.iendxXZ-1)cycle
c MP for F2 Y is uncut
c                         if(indy.lt.ibegy-1.or.
c     .                      indy.gt.iendy-1)cycle
                         if(indz.lt.ibegzXZ-1.or.
     .                      indz.gt.iendzXZ-1)cycle
c MP for F2 Y is uncot
                         ind2 = (Oy(ey)+ay) !along y
c                         ind2 = indy-ibegy+1
c                         ind13 = (indx-ibegx+1)+
c     .                           (indz-ibegz+1)*(iendx-ibegx+1)
                         ind13 = (indx-ibegxXZ+1)+
     .                           (indz-ibegzXZ+1)*(iendxXZ-ibegxXZ+1)
                         if(iprint.eq.1)then
                            write(*,*)PRINTRANK,'ind->x,y,z',
     .                        ind,indx,indy,indz,'->',ind2,ind13
                         endif
c    ....................prepare indices for YZ (for F)
                         ind = (Ox(ex)+ax)+(Oy(ey)+ay)*(nx+1)+
     .                         (Oz(ez)+az)*(ny+1)*(nx+1)
                         call global2local(ind,indx,indy,indz,
     .                        nx,ny,nz)
c MP for F X is uncut
c                         if(indx.lt.ibegx-1.or.
c     .                      indx.gt.iendx-1)cycle
                         if(indy.lt.ibegyYZ-1.or.
     .                      indy.gt.iendyYZ-1)cycle
                         if(indz.lt.ibegzYZ-1.or.
     .                      indz.gt.iendzYZ-1)cycle
c MP for F X is uncut
                         ind1 = (Ox(ex)+ax) !along x
c                         ind1 = indx-ibegx+1
                         ind23 = (indy-ibegyYZ+1)+
     .                           (indz-ibegzYZ+1)*(iendyYZ-ibegyYZ+1)
                         if(iprint.eq.1)then
                            write(*,*)PRINTRANK,'ind->x,y,z',
     .                        ind,indx,indy,indz,'->',ind1,ind23
                         endif
                         F2(ind2,ind13) = F(ind1,ind23) 
                      end do
                   end do
                end do
            end do
         end do
      end do
  
      end subroutine ReorderRHSforY

c Ux,Uy,Uz - knots vectors
c px,py,py - orders
c nx,ny,nz - number of intervals (problems size is (nx+1)*(ny+1)*(nz+1)
c nelemx,nelemy,nelemz - number of elements
c F input rhs (multiple vectors) 
c F2 output rhs
      subroutine ReorderRHSForZ
     .   (Ux,px,nx,nelemx,Uy,py,ny,nelemy,Uz,pz,nz,nelemz, 
     .    ibegxXZ,iendxXZ,nrankxXZ,
     .    ibegzXZ,iendzXZ,nrankzXZ,
     .    ibegxXY,iendxXY,nrankxXY,
     .    ibegyXY,iendyXY,nrankyXY,
     .    nrpx,nrpy,nrpz,F2,F3)
      implicit none
      integer(kind=4), intent(in) :: nx, px, nelemx
      integer(kind=4), intent(in) :: ny, py, nelemy
      integer(kind=4), intent(in) :: nz, pz, nelemz
      real   (kind=8), intent(in) :: Ux(0:nx+px+1)
      real   (kind=8), intent(in) :: Uy(0:ny+py+1)
      real   (kind=8), intent(in) :: Uz(0:nz+pz+1)
      double precision, intent(in) :: F2(0:ny,
     .    0:(iendxXZ-ibegxXZ+1)*(iendzXZ-ibegzXZ+1)-1)
      double precision, intent(out) :: F3(0:nz,
     .    0:(iendxXY-ibegxXY+1)*(iendyXY-ibegyXY+1)-1)
      integer(kind=4) :: mx,my,mz,ngx,ngy,ngz,ex,ey,ez
      integer(kind=4) :: kx,ky,kz,ax,ay,az,d
      integer(kind=4) :: Ox(nelemx),Oy(nelemy),Oz(nelemz)
      real   (kind=8) :: Jx(nelemx),Jy(nelemy),Jz(nelemz)
      real   (kind=8) :: Wx(px+1),Wy(py+1),Wz(pz+1)
      real   (kind=8) :: Xx(px+1,nelemx)
      real   (kind=8) :: Xy(py+1,nelemy)
      real   (kind=8) :: Xz(pz+1,nelemz)
      real   (kind=8) :: NNx(0:0,0:px,px+1,nelemx),
     .                   NNy(0:0,0:py,py+1,nelemy),
     .                   NNz(0:0,0:pz,pz+1,nelemz)
      integer, intent(in) :: 
     .    ibegxXZ,iendxXZ,nrankxXZ,
     .    ibegzXZ,iendzXZ,nrankzXZ,
     .    ibegxXY,iendxXY,nrankxXY,
     .    ibegyXY,iendyXY,nrankyXY
      integer, intent(in) :: nrpx,nrpy,nrpz
      integer :: nreppx,nreppy,nreppz !# elements per proc along x,y,z
      real   (kind=8) :: J,W,value
      integer :: ind,ind3,ind12,ind2,ind13,indx,indy,indz
      integer :: iprint
c
      iprint=0
c
      d=0
      mx  = nx+px+1
      ngx = px+1
      my  = ny+py+1
      ngy = py+1
      mz  = nz+pz+1
      ngz = pz+1

      call BasisData(px,mx,Ux,0,ngx,nelemx,Ox,Jx,Wx,Xx,NNx)
      call BasisData(py,my,Uy,0,ngy,nelemy,Oy,Jy,Wy,Xy,NNy)
      call BasisData(pz,mz,Uz,0,ngz,nelemz,Oz,Jz,Wz,Xz,NNz)

c-> parallel number of elements per processors
      nreppx = nelemx/nrpx
      nreppy = nelemy/nrpy
      nreppz = nelemz/nrpz
c<- parallel
      F3 = 0.d0
c-> parallel
c      do ex = 1,nelemx
       do ex = max(nreppx*nrankxXZ-px+1,1),
     .         min(nelemx,nreppx*(nrankxXZ+1)+px)
c MP now we have full Y for reading from F2
c but only partial Y for writing to F3
         do ey = 1,nelemy
c         do ey = max(nreppy*nranky-py+1,1),
c     .           min(nelemy,nreppy*(nranky+1)+py)
c MP now we have full Z for writing to F3
c but only partial Z for reading from F2
            do ez = 1,nelemz
c            do ez = max(nreppz*nrankz-pz+1,1),
c     .              min(nelemz,nreppz*(nrankz+1)+pz)
c<- parallel
                do ax = 0,px
                   do ay = 0,py
                      do az = 0,pz
c                        new ordering
                         ind = (Oz(ez)+az)+(Ox(ex)+ax)*(nz+1)+
     .                         (Oz(ey)+ay)*(nx+1)*(nz+1)
                         call global2local(ind,indx,indy,indz,
     .                        nx,ny,nz)
                         if(indx.lt.ibegxXY-1.or.
     .                      indx.gt.iendxXY-1)cycle
                         if(indy.lt.ibegyXY-1.or.
     .                      indy.gt.iendyXY-1)cycle
c MP for F3 Z is uncut
c                         if(indz.lt.ibegz-1.or.
c     .                      indz.gt.iendz-1)cycle
c                         ind3 = indz-ibegz+1
                         ind3 = (Oz(ez)+az) !along z
                         ind12 = (indx-ibegxXY+1)+
     .                           (indy-ibegyXY+1)*(iendxXY-ibegxXY+1)
                         if(iprint.eq.1)then
                            write(*,*)PRINTRANK,'ind->x,y,z',
     .                        ind,indx,indy,indz,'->',ind3,ind12
                         endif
c  ......................prepare indices for XZ (for F2)
                         ind = (Oy(ey)+ay)+(Ox(ex)+ax)*(ny+1)+
     .                         (Oz(ez)+az)*(nx+1)*(ny+1)
                         call global2local(ind,indx,indy,indz,
     .                        nx,ny,nz)
                         if(indx.lt.ibegxXZ-1.or.
     .                      indx.gt.iendxXZ-1)cycle
c MP for F2 Y is uncut
c                         if(indy.lt.ibegy-1.or.
c     .                      indy.gt.iendy-1)cycle
                         if(indz.lt.ibegzXZ-1.or.
     .                      indz.gt.iendzXZ-1)cycle
c MP for F2 Y is uncut
                         ind2 = (Oy(ey)+ay) !along y
c                         ind2 = indy-ibegy+1
                         ind13 = (indx-ibegxXZ+1)+
     .                           (indz-ibegzXZ+1)*(iendxXZ-ibegxXZ+1)
                         if(iprint.eq.1)then
                            write(*,*)PRINTRANK,'ind->x,y,z',
     .                        ind,indx,indy,indz,'->',ind2,ind13
                         endif
                         F3(ind3,ind12) = F2(ind2,ind13) 
                      end  do
                   end do
                end do
            end do
         end do
      end do
  
      end subroutine ReorderRHSforZ

      function fvalue(x,y,z) result (fval)
      implicit none
      real   (kind=8) :: x,y,z
      real   (kind=8) :: fval

      fval = 1.d0

      end function fvalue

      subroutine global2local(ind,indx,indy,indz,nx,ny,nz)
      integer,intent(in) :: ind
      integer :: ind_temp
      integer,intent(in) :: nx,ny,nz
      integer,intent(out) :: indx,indy,indz
c
      indz = ind / ((nx+1)*(ny+1))
      ind_temp = ind - indz*(nx+1)*(ny+1)
      indy = ind_temp / (nx+1)
      ind_temp = ind_temp - indy*(nx+1)
      indx = ind_temp 
c
      end subroutine global2local

      end module projection_engine

