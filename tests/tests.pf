@test
subroutine test_knot1()
   use knot_vector, only: FillOpenKnot
   use pfunit_mod
   implicit none
   integer(kind = 4) :: n, p
   real (kind = 8), allocatable, dimension(:) :: U
   real (kind = 8), allocatable, dimension(:) :: res

   ! Number of subintervals is N = n-p+1.

   n = 0
   p = 0
   ! N = 1
   allocate(res(n + p + 2))
   call FillOpenKnot(res, n, p)
   U = (/ 0.0, 1.0 /)
   !@assertEqual(U, res)
   !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!! FIX THIS !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
   deallocate(res)

   n = 0
   p = 1
   ! N = 0
   allocate(res(n + p + 2))
   call FillOpenKnot(res, n, p)
   U = (/ 0.0, 1.0, 1.0 /)
   !@assertEqual(U, res)
   !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!! FIX THIS !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
   deallocate(res)

   n = 1
   p = 0
   ! N = 2
   allocate(res(n + p + 2))
   call FillOpenKnot(res, n, p)
   U = (/ 0.0, 0.5, 1.0 /)
   @assertEqual(U, res)
   deallocate(res)

   n = 3
   p = 0
   ! N = 4
   allocate(res(n + p + 2))
   call FillOpenKnot(res, n, p)
   U = (/0.0, 0.25, 0.5, 0.75, 1.0/)
   @assertEqual(U, res)
   deallocate(res)

   n = 4
   p = 1
   ! N = 4
   allocate(res(n + p + 2))
   call FillOpenKnot(res, n, p)
   U = (/0.0, 0.0, 0.25, 0.5, 0.75, 1.0, 1.0/)
   @assertEqual(U, res)
   deallocate(res)
   
   n = 5
   p = 2
   ! N = 4
   allocate(res(n + p + 2))
   call FillOpenKnot(res, n, p)
   U = (/0.0, 0.0, 0.0, 0.25, 0.5, 0.75, 1.0, 1.0, 1.0/)
   @assertEqual(U, res)
   deallocate(res)

   n = 6
   p = 3
   ! N = 4
   allocate(res(n + p + 2))
   call FillOpenKnot(res, n, p)
   U = (/0.0, 0.0, 0.0, 0.0, 0.25, 0.5, 0.75, 1.0, 1.0, 1.0, 1.0/)
   @assertEqual(U, res)
   deallocate(res)

end subroutine test_knot1



@test
subroutine test_knot2()
   use knot_vector, only: CountSpans
   use pfunit_mod
   implicit none
   integer :: res
   real (kind = 8), DIMENSION(8) :: A

   A = (/ 1, 2, 3, 4, 5, 6, 7, 8 /)
   res = CountSpans(1, 1, A)
   @assertEqual(1, res)
end subroutine test_knot2


@test
subroutine test_knot3()
   use knot_vector, only: PrepareKnot
   use pfunit_mod
   implicit none
   integer(kind = 4) :: n, p
   real (kind = 8), allocatable, dimension(:) :: U
   integer(kind = 4) :: nelem


end subroutine test_knot3



