#======================================================================
#
#  The makefile was last modified on $Date: 2006/10/16 18:27:14 $ by $Author: dzubiaur $
#
#======================================================================
#
# To compile:     make C=XXX where XXX is LAPL, LAPLZ, LAPLE (2d code)
#                                         or  R, Z (1d code)
#                            XXX options are set in m_files
#                 make C=XXX OPT=1   - compile in OPT mode
#    preprocess:  make export C=XXX
#    tar:         make tar C=XXX
#    tar & gzip:  make tgz C=XXX
#    clean:       make clean C=XXX <OPT=1> _or_ make realclean
#
#======================================================================
PARALLEL=1
ifeq ($(PARALLEL),1)
  include m_options_parallel
else
  include m_options
endif

.SUFFIXES:
.PHONY: build_error banner tar tgz clean realclean link done

SRC_DIR		=  .
REL_DIR		=  ../

# Preprocessing Flags
###############################
include ./m_files
###############################


obj_path = _OBJ
EXEC = l2

# this is real target if nothing is defined
link: banner EXEC/$(EXEC) done


ifeq ($(COMPILER), XLF90)
FFLAGS		+=  -qmoddir=./$(obj_path) -I./$(obj_path)
endif

ifeq ($(COMPILER), IFC)
FFLAGS		+=  -module $(obj_path) -module MODULE -I./$(obj_path) 
endif

ifeq ($(COMPILER), IFORT)
FFLAGS		+=  -module $(obj_path) -module MODULE -I./$(obj_path) 
endif

ifeq ($(COMPILER), PGF90)
FFLAGS		+=  -module $(obj_path) -module MODULE -I./$(obj_path) 
endif

ifeq ($(COMPILER), MPIF90)
FFLAGS		+=  -module $(obj_path) -module MODULE -I./$(obj_path)
endif

ifeq ($(COMPILER), MPICH90)
FFLAGS		+=  -module $(obj_path) -module MODULE -I./$(obj_path)
endif

ifeq ($(COMPILER), GFORTRAN)
FFLAGS		+= -I./$(obj_path) -I./MODULE 
endif

PREC_FLAGS	= $(INCLUDES)
                -DPARALLEL_MODE=$(PARALLEL)

ifeq ($(COMPILER), XLF90)
PREC_FLAGS	= -WF,-DEM_MODE=$(EM),-DC_MODE=$(COMPLEX),-DMAXEQNS_DEF=$(MAXEQNS),-DDIM2=$(DIM2) $(INCLUDES)
endif

# workfiles created by compiler all over the place
TMP_FILES       += *.stb
#======================================================================

#we'll search for source files in these directories
VPATH = $(sort $(dir $(SOURCE_ALL)))

# dot_o can be changed to .obj for Windows
dot_o = .o
objF :=  $(notdir $(filter %$(dot_o),$(SOURCE_ALL:.F=$(dot_o))))
objc :=  $(notdir $(filter %$(dot_o),$(SOURCE_ALL:.c=$(dot_o))))

OBJECT_ALL := $(addprefix $(obj_path)/,$(objF) $(objc))
#======================================================================
# Link
EXEC/$(EXEC): $(obj_path)/.dummy EXEC/.dummy $(OBJECT_ALL)
	@echo
	@echo Linking EXEC/$(EXEC)
	@echo ----------------------
	@echo $(FF) $(FFLAGS) -o EXEC/$(EXEC) //OBJECT_ALL// $(USER_LIB)
	@$(FF) $(FFLAGS) -o EXEC/$(EXEC) $(OBJECT_ALL) $(USER_LIB)

# initialization banner
banner:
	@echo
ifeq ($(OPT),1)
	@echo OPT compiling into $(obj_path) for $(EXEC)
else
	@echo Compiling into $(obj_path) for $(EXEC)
endif
	@echo

done:
	@echo
	@echo Done: EXEC/$(EXEC) complete.
	@echo

$(obj_path)/.dummy:
	@echo Creating $(obj_path) directory ...
	@if [ -d  $(obj_path) ] ; then \
		touch $@; \
	   else mkdir $(obj_path); touch $@ ; \
	   fi

EXEC/.dummy:
	@echo Creating EXEC directory ...
	@if [ -d  EXEC ] ; then \
		touch $@; \
	   else mkdir EXEC; touch $@ ; \
	   fi


# Compile .f to create .F
$(obj_path)/%$(dot_o): %.F
	@echo Compiling $<
	@echo $(FF) $(FFLAGS) $(PREC_FLAGS) $(INCLUDES) -o $@ -c $<
	$(FF) $(FFLAGS) $(PREC_FLAGS) $(INCLUDES) -o $@ -c $<

$(obj_path)/%$(dot_o): %.c
	@echo Compiling $<
	$(CC) -c $< $(CFLAGS) -o $@


# create default compiler options from the template
m_options: MAKE-SHARED/m_compile
	@if [ -f m_options ] ; then \
	    touch m_options ; \
	    echo "MAKE-SHARED/m_compile changed !" ;\
	    echo "@@@@@@@@@@@@@@@@@@@@@@@@@@@@@ !" ;\
	  else \
	    cp MAKE-SHARED/m_compile m_options ;\
	  fi
#==================================================================
# auto dependencies magic
ifndef NODEPENDECIES

# auto dependencies require gcc, if you do not have it, then you
#  can desable autodependenceis using
#     make NODEPENDECIES=1 ...other options....

dep_files = $(patsubst %$(dot_o),%.P,$(OBJECT_ALL))

-include $(dep_files) $(obj_path)/.dummy
$(dep_files): $(obj_path)/.dummy

FIX_P = ( echo -n $@ $(obj_path)/ ; cat $@-tmp ) > $@

$(obj_path)/%.P: %.c
	@echo mkdeps $< '>' $@ 
	@(gcc -MM $(PREC_FLAGS) $(INCLUDES) $< > $@-tmp) 2> /dev/null 
	@$(FIX_P)
	@rm $@-tmp

$(obj_path)/%.P: %.F
	@echo mkdeps $< '>' $@ 
	@sed \
	    -e '/^[^#]/d' \
	    -e '/.*\\ *$$/s/\\* *$$//' \
	    -e '/\/\*/s/\/\*.*//' \
	    -e "s/'//g" \
	    -e 's/`//g' \
		  		$<  > $(*F)-sed.c
	@(gcc -xc -MM $(PREC_FLAGS) $(INCLUDES) $(*F)-sed.c > $@-tmp) 
	@echo $@ " " \\ > $@
	@sed \
	      -e 's,$(*F)-sed\.o,$$\(obj_path\)/$(*F)$(dot_o),g' \
	      -e 's,$(*F)-sed.c,$(*F).F,g' \
	      -e 's,$(*F)-sed:,$$\(obj_path\)/$(*F)$(dot_o):,g' \
	      -e 's,$(*F)-sed$$,$(*F).F,g' \
	   $@-tmp >> $@
	@rm -f $(*F)-sed.c $@-tmp

endif
#======================================================================
#export magic
OTHER_FILES += makefile m_files \
   MAKE-SHARED/makefile-common MAKE-SHARED/m_compile MAKE-SHARED/prep.tcl
exp_path = ./export_$(C)
blk_path = $(sort $(dir $(BLK_FILES)))
# for ffld/commons we need to add also ffld
blk_exp = $(blk_path) $(dir $(patsubst %/,%,$(blk_path)))
all_dirs = $(patsubst ./%,%,$(dir $(SOURCE_ALL) $(OTHER_FILES)) $(blk_exp))
exp_dirs = $(sort $(addprefix $(exp_path)/,$(all_dirs)))
export:
	rm -rf $(exp_path)
	mkdir $(exp_path)
	for d in $(exp_dirs) ; do mkdir $$d ; done
	for f in $(SOURCE_ALL) $(BLK_FILES) ; do echo $(exp_path)/$$f ;\
	  (tclsh MAKE-SHARED/prep.tcl $(COMPLEX) $(EM) $(MAXEQNS) \
                            $(PARALLEL)\
                            < $$f > $(exp_path)/$$f); \
	  done
	for f in $(OTHER_FILES) ; do echo $(exp_path)/$$f ;\
	  cp $$f $(exp_path)/$$f ; done
	@echo ...
	tar -czf $(TAR_NAME)_$(C).tgz $(exp_path)
	@echo $(exp_path)/ AND $(TAR_NAME)_$(C).tgz CREATED

# Ftof_FILES	:= $(patsubst %.F,%.f,$(wildcard */*.F))

# tar or tar/gzip

tar: 
	@tar -cvf $(TAR_NAME).tar $(TAR_FILES) $(OTHER_FILES)
tgz: 
	@tar -czvf $(TAR_NAME).tgz $(TAR_FILES) $(OTHER_FILES) 

list:
	@echo LIST OF SOURCE FILES:
	@echo $(SOURCE_ALL)
	@echo
	@echo LIST OF SOURCE PATHS SEARCHED IN:
	@echo $(VPATH)
	@echo
	@echo LIST OF DIRECTORIES SEARCHED FOR INCLUDES:
	@echo $(INCLUDES)
	@echo
	@echo PREPROCESSOR AND COMPILER OPTIONS:
	@echo $(PREC_FLAGS)
	@echo
	@echo $(FFLAGS)
	@echo

clean:
	@rm -f $(OBJECT_ALL) $(dep_files) EXEC/$(EXEC)

realclean:
	@rm -rf _OBJ_* EXEC export* $(TAR_NAME)* $(TMP_FILES)
#   these are hidden files created by editors and cvs conflicts
	@rm -f .\#* */.\#* */*/.\#* \#*\# */\#*\# */*/\#*\# *~ */*~ */*/*~


###############################################################
# My own problems: DAVID PARDO
###############################################################
lshape:
	cp $(SRC_DIR)/files/inputs/input_Lq $(SRC_DIR)/files/input;
#	cp $(SRC_DIR)/files/inputs/input_LqBA_01degrees $(SRC_DIR)/files/input;
#	cp $(SRC_DIR)/files/inputs/input_TEST $(SRC_DIR)/files/input;
#	cp $(SRC_DIR)/files/inputs/input_LqBA $(SRC_DIR)/files/input;
	make C=lshape
	cp $(SRC_DIR)/problems/Lshape/control $(SRC_DIR)/files/control

shock:
	cp $(SRC_DIR)/files/inputs/input_quad $(SRC_DIR)/files/input;
	make C=shock
	cp $(SRC_DIR)/problems/shock/control $(SRC_DIR)/files/control

babuska:
	cp $(SRC_DIR)/files/inputs/input_babuska $(SRC_DIR)/files/input;
	make C=babuska
	cp $(SRC_DIR)/problems/babuska/control $(SRC_DIR)/files/control

babuska2:
	cp $(SRC_DIR)/files/inputs/input_babuska2 $(SRC_DIR)/files/input;
	make C=babuska2
	cp $(SRC_DIR)/problems/babuska2/control $(SRC_DIR)/files/control

study_eigenv:
	cp $(SRC_DIR)/files/inputs/input_quad_eigenv $(SRC_DIR)/files/input;
	make C=shock
	cp $(SRC_DIR)/problems/shock/control_eigenv $(SRC_DIR)/files/control

isotropic:
	make C=isotropic;
	cp $(SRC_DIR)/problems/isotropic/control $(SRC_DIR)/files/control

orthotropic:
	make C=orthotropic;
	cp $(SRC_DIR)/problems/orthotropic/control $(SRC_DIR)/files/control

antenna:
	make C=antenna;
	cp $(SRC_DIR)/problems/antenna/control $(SRC_DIR)/files/control

antenna2:
	make C=antenna2;
	cp $(SRC_DIR)/problems/antenna2/control $(SRC_DIR)/files/control
	cp $(SRC_DIR)/files/inputANTENNA2 $(SRC_DIR)/files/input;

antmagnetic:
	cp $(SRC_DIR)/problems/antmagnetic/commons/emconstants.blk $(SRC_DIR)/commons/emconstants.blk
	make C=antmagnetic;
	cp $(SRC_DIR)/problems/antmagnetic/control $(SRC_DIR)/files/control
##	cp $(SRC_DIR)/files/inputANTMAGNETIC2 $(SRC_DIR)/files/input;
	cp $(SRC_DIR)/files/inputTEST $(SRC_DIR)/files/input;

antelectric:
	make C=antelectric;
	cp $(SRC_DIR)/problems/antelectric/control $(SRC_DIR)/files/control
##	cp $(SRC_DIR)/files/inputANTMAGNETIC2 $(SRC_DIR)/files/input;
	cp $(SRC_DIR)/files/inputTEST2E $(SRC_DIR)/files/input;

DC:
	make C=DC;

AC:
	make C=AC;

logging_edge:
	make C=logging_edge;
	cp $(SRC_DIR)/problems/logging_edge/control $(SRC_DIR)/files/control
	cp $(SRC_DIR)/files/inputs/input_quadEv2 $(SRC_DIR)/files/input

planewave:
	cp $(SRC_DIR)/files/inputs/input_diffrq $(SRC_DIR)/files/input;
#	cp $(SRC_DIR)/files/inputs/input_quadE $(SRC_DIR)/files/input;
	make C=planewave
	cp $(SRC_DIR)/problems/planewave/control $(SRC_DIR)/files/control

batest1:
	cp $(SRC_DIR)/files/inputs/inputTRY $(SRC_DIR)/files/input;
#	cp $(SRC_DIR)/files/inputs/input_quadE $(SRC_DIR)/files/input;
	make C=batest1
	cp $(SRC_DIR)/problems/planewave/control $(SRC_DIR)/files/control
#
waveguide:
#	cp $(SRC_DIR)/files/inputs_Hwg/input_Hwg_horizontal $(SRC_DIR)/files/input;
#	cp $(SRC_DIR)/files/inputs_Hwg/data_Hwg_horizontal $(SRC_DIR)/files/data_Hwg;
#	cp $(SRC_DIR)/files/inputs_Hwg/input_Hwg_inductivewallsymmetric_2 $(SRC_DIR)/files/input;
#	cp $(SRC_DIR)/files/inputs_Hwg/dataFILTER_5_IRIS $(SRC_DIR)/files/data_Hwg;
#	cp $(SRC_DIR)/files/inputs_Hwg/inputFILTER_5_IRIS $(SRC_DIR)/files/input;
	cp $(SRC_DIR)/files/inputs_Hwg/data_phase_shifter_04_09_07 $(SRC_DIR)/files/data_Hwg;
	cp $(SRC_DIR)/files/inputs_Hwg/inputFILTER_5_IRIS_H_plane_v2 $(SRC_DIR)/files/input;
#	cp $(SRC_DIR)/files/inputs/input_quadE $(SRC_DIR)/files/input;
#	cp $(SRC_DIR)/files/inputs_Hwg/data_Hwg_inductivewallsymmetric_2 $(SRC_DIR)/files/data_Hwg;
#	cp $(SRC_DIR)/files/inputs_Hwg/input_Hwg_inductivewallsymmetric_2v2 $(SRC_DIR)/files/input;
#	cp $(SRC_DIR)/files/inputs_Hwg/data_Hwg_inductivewallsymmetric_2v2 $(SRC_DIR)/files/data_Hwg;
	make C=WAVEGUIDE
	cp $(SRC_DIR)/problems/waveguide/control $(SRC_DIR)/files/control

waveguide_model:
	cp $(SRC_DIR)/files/inputs_Hwg/input_Hwg_inductivewallsymmetric_2v2 $(SRC_DIR)/files/input;
	cp $(SRC_DIR)/files/inputs_Hwg/data_Hwg_inductivewallsymmetric_2v2 $(SRC_DIR)/files/data_Hwg;
	make C=WAVEGUIDE
	cp $(SRC_DIR)/problems/waveguide/control $(SRC_DIR)/files/control

automatic_electrode_test:
	make automatic_test

automatic_electrode_final:
	make automatic_final

acou_elas:
	make C=acou_elas;
	cp $(SRC_DIR)/problems/acou_elas/control $(SRC_DIR)/files/control
